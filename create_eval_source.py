# Plan
# - read the list of fitted primitives (.fit file)
# - read the expression generated by the GP (a regular .txt file)
# - generate a .cpp file with the read expression and fitted primitives in eval()


import sys
import re


def read_fit(fit_filename):
    '''
    Create a list of primitives from the a file. 
    A primitive is a list made of:
    name, type, parameter1, parameter2, ...
    where: name is a string, type is a string, parameters are float
    '''

    f = open(fit_filename)

    list_primitives = []
    count = 0

    for line in f:
        elements = line.strip().split()
        if len(elements)==0:
            continue

        prim_type = elements[0]
        parameters = []
        for i in range(1, len(elements)):
            parameters.append(float(elements[i]))

        primitive = []
        prim_name = prim_type + str(count)
        primitive.append(prim_name)
        primitive.append(prim_type)
        for parameter in parameters:
            primitive.append(parameter)

        count = count + 1

        list_primitives.append(primitive)

    f.close()
    return list_primitives


def read_expression(exp_filename):
    f = open(exp_filename)
    line = f.readline()
    line = line.strip()
    f.close()
    return line


def create_eval_cpp(prim_list, expression, cpp_filename):
    f = open(cpp_filename, "w")
    
    f.write('#include "operations.h"\n')
    f.write('#include "primitives.h"\n')
    f.write('\n')
    f.write('double eval(double x, double y, double z) {')
    f.write('\n')
    # generate the list of primitives
    # one local variable for each instantiated primitive
    for prim in prim_list:
        name = prim[0]
        prim_type = prim[1]
        # the parameters 
        f.write('double %s_parameters[] = ' % name)
        f.write('{')
        # write the numerical values of the parameters
        for i in range(2, len(prim)-1):
            f.write(str(prim[i])+',')
        f.write(str(prim[-1]))
        f.write('};\n')
        # the primitive 
        f.write('double %s = ' % name)
        f.write('primitive_%s' % prim_type)
        f.write('(x,y,z,%s_parameters);\n' % name)

    # replace union, ... by set_union, ... in expression
    cpp_expression = expression
    cpp_expression = re.sub('union', 'set_union', cpp_expression)
    cpp_expression = re.sub('subtraction', 'set_subtraction', cpp_expression)
    cpp_expression = re.sub('negation', 'set_negation', cpp_expression)
    cpp_expression = re.sub('intersection', 'set_intersection', cpp_expression)
    
    # replace [] by () for the function call symbols
    # [ and ] need to be escaped but not ( and )
    cpp_expression = re.sub('\[', '(', cpp_expression)
    cpp_expression = re.sub('\]', ')', cpp_expression)

    f.write('double model = %s;\n' % cpp_expression)

    f.write('return model;\n')
    f.write('}\n')

    f.close()


def main(fit_filename, exp_filename, cpp_filename):
    prim_list = read_fit(fit_filename)
    expression = read_expression(exp_filename)
    create_eval_cpp(prim_list, expression, cpp_filename)


def usage(progname):
    print('Usage: ')
    print(progname + ' model.fit model.txt model.cpp')
    print('Where:')
    print('\t model.fit: a file containing a list of fitted primitives')
    print('\t model.txt: a file containing an expression for the object')
    print('\t model.cpp: the generated c++ file corresponding to the expression')


if __name__ == '__main__':
    num_args = len(sys.argv)
    if num_args != 4:
        usage(sys.argv[0])
        sys.exit(1)

    fit_filename = sys.argv[1]
    exp_filename = sys.argv[2]
    cpp_filename = sys.argv[3]
    main(fit_filename, exp_filename, cpp_filename)
